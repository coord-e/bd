#!/bin/bash

readonly BD_CACHE="$HOME/.cache/bd"

if [ ! -d "$BD_CACHE" ]; then
  mkdir $BD_CACHE
fi

SCRIPT=$1
shift
ARGS=$@
SCRIPT_NAME=$SCRIPT

function info (){
  echo -e "\033[0;32m[INFO] \033[0m\033[0;01m $1\033[0;0m" >&2
}

function error (){
  echo -e "\033[0;31m[ERROR] \033[0m\033[0;01m $1\033[0;0m" >&2
}

function warn (){
  echo -e "\033[0;33m[WARN] \033[0m\033[0;01m $1\033[0;0m" >&2
}

function confirm (){
  local MSG=$1
  while true; do
    printf '%s ' "$MSG"
    printf "[y/n] > "
    read input
    if [ "$input" = "y" ]; then
      return 0;
    elif [ "$input" = "n" ]; then
      return 1;
    fi
  done
}

function name() {
  SCRIPT_NAME=$1
}

function description() {
  if [ -t 1 ]; then
    SCRIPT_DESCRIPTION=$(cat)
  else
    SCRIPT_DESCRIPTION=$@
  fi
}

total_progress=0
current_progress=0

function iter() {
  iterations=$(eval "echo $@")
  total_progress=$(wc -w <<< $iterations)
}

function range() {
  local start=0
  local end=0
  case "$#" in
    "1")
      end=$1
      ;;
    "2")
      start=$1
      end=$2
      ;;
  esac
  iterations=$(eval "echo {$start..$end}")
  total_progress=$(wc -w <<< $iterations)
}

function progress() {
  current_progress=$((current_progress += 1))
  if [[ "$total_progress" == "0" ]]; then
    local status="$(printf "%3d" $current_progress)."
  else
    local percentage=$(( current_progress * 100 / total_progress ))
    local status="$(printf "%3d" $percentage)%"
  fi
  local text="$1"
  echo -e "\033[0;32m $status -> \033[0m\033[0;01m $text\033[0;0m"

  if [[ $current_progress -eq $total_progress ]]; then
    current_progress=0
    total_progress=0
  fi
}

function args() {
  local args_spec=$@

  declare -A types=(
   [string]=1  [number]=2  [bool]=3
  )

  declare -A opts

  local parsing=""

  opts["--help"]="bool"
  for OPT in $args_spec
  do
    read -r type example <<< $(sed -e 's/:\(.*\)/ "\1"/g' <<< $OPT)
    example=${example//\"/}

    if [ -n "$parsing" ]; then
      if [[ -n "${types[$type]}" ]]; then
        opts[$parsing]=$OPT
        parsing=""
        case $type in
          'number' )
            if [[ -n $example ]] && [[ ! $example =~ ^-?[0-9]+([.][0-9]+)?$ ]]; then
              error "arg: parse failed; number is required as example but got \"$example\""
              exit -1
            fi
            ;;
          'bool' )
            if [[ -n $example ]]; then
              error "arg: parse failed; example value in flag"
              exit -1
            fi
            ;;
        esac
      else
        error "arg: parse failed; unexpected non-type expression $OPT"
        exit -1
      fi
    else
      if [[ -n "${types[$type]}" ]]; then
        error "arg: parse failed; unexpected type expression $OPT"
        exit -1
      fi
      if [[ $OPT != -* ]]; then
        error "arg: parse failed; option must be started with -"
        exit -1
      fi
      parsing=$OPT
    fi
  done

  declare -A already_got
  parsing=""
  for OPT in $ARGS
  do
    if [ -n "$parsing" ]; then
      read -r type example <<< $(sed -e 's/:\(.*\)/ "\1"/g' <<< ${opts[$parsing]})

      case $type in
        'number' )
          if [[ ! $OPT =~ ^-?[0-9]+([.][0-9]+)?$ ]]; then
            error "arg: parse failed; number is required but got \"$OPT\""
            exit -1
          fi
          ;;
      esac

      eval "readonly arg_${parsing//-/}=$OPT"
      already_got[$parsing]=1
      parsing=""
    else
      if [[ -n "${opts[$OPT]}" ]]; then
        if [[ -n "${already_got[$OPT]}" ]]; then
          error "arg: parse failed; $OPT is already supplied"
          exit -1
        fi
        read -r type example <<< $(sed -e 's/:\(.*\)/ "\1"/g' <<< ${opts[$OPT]})

        if [[ $type == "bool" ]]; then
          eval "readonly arg_${OPT//-/}=true"
          already_got[$OPT]=1
          parsing=""
        else
          parsing=$OPT
        fi
      else
        if [[ $OPT != -* ]]; then
          error "arg: parse failed; unexpected expression $OPT"
          exit -1
        else
          error "arg: parse failed; unknown option $OPT"
          exit -1
        fi
      fi
    fi
  done

  for OPT in "${!opts[@]}"
  do
    if [[ -z "${already_got[$OPT]}" ]]; then
      read -r type example <<< $(sed -e 's/:\(.*\)/ "\1"/g' <<< ${opts[$OPT]})
      example=${example//\"/}

      case ${type} in
        'bool' )
          eval "readonly arg_${OPT//-/}=false"
          ;;
        * )
          eval "readonly arg_${OPT//-/}=$example"
          ;;
      esac
    fi
  done

  if $arg_help; then
    echo -n "usage: $SCRIPT_NAME "
    for OPT in "${!opts[@]}"; do
      read -r type example <<< $(sed -e 's/:\(.*\)/ "\1"/g' <<< ${opts[$OPT]})
      if [[ -z "$example" ]]; then
        example=""
      else
        example="(=${example//\"/})"
      fi

      printf "[%s %s%s] " "$OPT" "${type}" "${example}"
    done
    printf "\n\n"
    while read line; do
      printf "\t%s\n" "$line"
    done <<< $SCRIPT_DESCRIPTION
    exit 0
  fi
}

source $SCRIPT

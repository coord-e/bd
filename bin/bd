#!/bin/bash

readonly BD_CACHE="$HOME/.cache/bd"

if [ ! -d "$BD_CACHE" ]; then
  mkdir $BD_CACHE
fi

SCRIPT=$1
shift
ARGS=$@
SCRIPT_NAME=$SCRIPT

function info (){
  echo -e "\033[0;32m[INFO] \033[0m\033[0;01m $1\033[0;0m" >&2
}

function error (){
  echo -e "\033[0;31m[ERROR] \033[0m\033[0;01m $1\033[0;0m" >&2
}

function warn (){
  echo -e "\033[0;33m[WARN] \033[0m\033[0;01m $1\033[0;0m" >&2
}

function confirm (){
  local MSG=$1
  while true; do
    printf '%s ' "$MSG"
    printf "[y/n] > "
    read input
    if [ "$input" = "y" ]; then
      return 0;
    elif [ "$input" = "n" ]; then
      return 1;
    fi
  done
}

function name() {
  SCRIPT_NAME=$1
}

function profile() {
  local file=$1
  shift
  local prof_commands=$@
  local prof_file_id=$(md5sum $file | awk '{print $1}')
  local prof_com_id=$(echo "$@" | md5sum | awk '{print $1}')
  local prof_id=$prof_file_id.$prof_com_id
  local prof_file=$BD_CACHE/$prof_id
  if [ -f "$prof_file" ]; then
    echo $prof_file
    return 0
  fi

  warn 'Profiling on the first run...'
  lib/prof.bash $file $prof_commands > $prof_file
  warn 'Done profiling and cached the result.'
  echo $prof_file
}

prof_file=$(profile $SCRIPT progress)
total_progress=$(cat $prof_file | grep 'progress' | awk '{print $2}')
current_progress=0

function progress() {
  current_progress=$((current_progress += 1))
  local percentage=$(( current_progress * 100 / total_progress ))
  local status="$(printf "%3d" $percentage)%"
  local text="$1"
  echo -e "\033[0;32m $status -> \033[0m\033[0;01m $text\033[0;0m"
}

function args() {
  local args_spec=$@

  declare -A types=(
   [string]=1  [number]=2  [bool]=3
  )

  declare -A opts

  local parsing=""

  for OPT in $args_spec
  do
    if [ -n "$parsing" ]; then
      if [[ -n "${types[$OPT]}" ]]; then
        opts[$parsing]=$OPT
        parsing=""
      else
        error "arg: parse failed; unexpected non-type expression $OPT"
        exit -1
      fi
    else
      if [[ -n "${types[$OPT]}" ]]; then
        error "arg: parse failed; unexpected type expression $OPT"
        exit -1
      fi
      if [[ $OPT != -* ]]; then
        error "arg: parse failed; option must be started with -"
        exit -1
      fi
      parsing=$OPT
    fi
  done

  local arg_file=$(mktemp)
  parsing=""
  for OPT in $ARGS
  do
    if [ -n "$parsing" ]; then
      case ${opts[$parsing]} in
        'number' )
          if [[ ! $OPT =~ ^-?[0-9]+([.][0-9]+)?$ ]]; then
            error "arg: parse failed; number is required but got \"$OPT\""
            exit -1
          fi
          ;;
      esac

      eval "readonly arg_${parsing//-/}=$OPT"
      parsing=""
    else
      if [[ -n "${opts[$OPT]}" ]]; then
        parsing=$OPT
      else
        if [[ $OPT != -* ]]; then
          error "arg: parse failed; unexpected expression $OPT"
          exit -1
        else
          error "arg: parse failed; unknown option $OPT"
          exit -1
        fi
      fi
    fi
  done
}

source $SCRIPT
